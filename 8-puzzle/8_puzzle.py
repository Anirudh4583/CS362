# -*- coding: utf-8 -*-
"""8-Puzzle.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1vEHNpn7oq9IMmftu3s3DOZg_u_2jOJ7N
"""

import numpy as np
from copy import deepcopy
import random
import time
import os, psutil
import resource

def h1(curr_state, goal_state):
    # Indices of that would sort the goal state
    goal_indices = np.argsort(goal_state.reshape(-1,1), axis=0)
    # Indices of that would sort the current state
    curr_indices = np.argsort(curr_state.reshape(-1,1), axis=0)
    # Integer division of the indices by 3 gives the value of first row i.e. indices 0, 1 and 2
    # as 0, second row i.e. indices 3, 4 and 5 as 2 and third row i.e. indices 6, 7 and 8 as 2. 
    x = (abs(goal_indices // 3 - curr_indices // 3))
    # Taking Remainder by 3 gives the value of first column, i.e. indices 0, 3 and 6 as 0 and so on... 
    y = (abs(goal_indices % 3 - curr_indices % 3))
    h = np.sum(x + y)
    return h

def h2(curr_state, goal_state):
    # Sums up all the true values returned for different cells in the matrix
    h = np.sum(curr_state != goal_state)
    return h

def generate_instance(goal_state, depth, debug=False):
  
    # Co-ordinates of blank tile of previous state 
    x_prev, y_prev = np.array(np.where(goal_state == 0)).reshape(-1)
    curr_state = np.copy(goal_state)
    # Visited numpy array of flattened state vectors
    visited = np.array([curr_state.reshape(-1)])
    n = depth
    if debug == True:
        print(f"Depth: {depth-n}")
        print(f"h1 value: {h1(curr_state, goal_state)}\th2 value : {h2(curr_state, goal_state)}")
        print(curr_state, end='\n\n')
    while(n):
        # Stores list of all possible locations of blank tile, from the current state
        possible_states = []
        if x_prev > 0:
            possible_states.append([x_prev-1, y_prev])
        if x_prev < 2:
            possible_states.append([x_prev+1, y_prev])
        if y_prev > 0:
            possible_states.append([x_prev, y_prev-1])
        if y_prev < 2:
            possible_states.append([x_prev, y_prev+1])
        # Randomly chooses a position for the blank tile, from the possible choices 
        x_new, y_new = random.choice(possible_states)
        # Swaps the position of previous blank tile with the chosen blank tile
        curr_state[x_new, y_new], curr_state[x_prev, y_prev] = curr_state[x_prev, y_prev], curr_state[x_new, y_new]
        if curr_state.reshape(-1).tolist() not in visited.tolist():
            # If current state is not visited, add it to visited and reduce depth
            visited = np.vstack((visited, curr_state.reshape(-1)))
            n -= 1
            if debug == True:
                if x_new > x_prev:
                    step = "Down"
                elif x_new < x_prev:
                    step = "Up"
                elif y_new > y_prev:
                    step = "Right"
                else:
                    step = "Left"
                print(f"Depth: {depth-n}\tStep taken to reach: {step}")
                print(f"h1 value: {h1(curr_state, goal_state)}\th2 value : {h2(curr_state, goal_state)}")
                print(curr_state, end='\n\n')
            x_prev, y_prev = x_new, y_new
        else:
            # If visited, revert back to previous state and repeat the same process, untill we get a visited state
            curr_state[x_new, y_new], curr_state[x_prev, y_prev] = curr_state[x_prev, y_prev], curr_state[x_new, y_new]
    return curr_state

GOAL_STATE = np.array([[0, 1, 2], [3, 4,5], [6, 7, 8]])
print("Goal State:\n", GOAL_STATE)

# Generating random instance
depth = 16
CURR_STATE = generate_instance(GOAL_STATE, depth, debug=False)
print(CURR_STATE)

# Heuristic 1
print("Value from h1:", h1(CURR_STATE, GOAL_STATE))

# Heuristic 2
print("Value from h2:", h2(CURR_STATE, GOAL_STATE))

CURR_STATE = generate_instance(GOAL_STATE, 10)

print(CURR_STATE)

def get_possible_moves(curr_state):
    row, col = np.array(np.where(curr_state == 0)).reshape(-1)
    possible_moves = []
    if(row > 0):
        next_state = curr_state.copy()
        next_state[row, col], next_state[row-1, col] = next_state[row-1, col], next_state[row, col]
        possible_moves.append(next_state)
    if(row < 2):
        next_state = curr_state.copy()
        next_state[row, col], next_state[row+1, col] = next_state[row+1, col], next_state[row, col]
        possible_moves.append(next_state)
    if(col > 0):
        next_state = curr_state.copy()
        next_state[row, col], next_state[row, col-1] = next_state[row, col-1], next_state[row, col]
        possible_moves.append(next_state)
    if(col < 2):
        next_state = curr_state.copy()
        next_state[row, col], next_state[row, col+1] = next_state[row, col+1], next_state[row, col]
        possible_moves.append(next_state)
    return possible_moves

def sort_by_heuristic(possible_moves, goal_state, heuristic):
    if heuristic == 1:
        sorted_possible_moves = sorted(possible_moves, key=lambda x: h1(x, goal_state))
    if heuristic == 2:
        sorted_possible_moves = sorted(possible_moves, key=lambda x:h2(x, goal_state))
    return sorted_possible_moves

def solve2(curr_state, goal_state, heuristic=0):
    visited = np.array([])
    frontier = np.array([curr_state.reshape(-1)])
    while (curr_state.tolist() != goal_state.tolist()):
        print(curr_state, end="\n\n")
        possible_moves = get_possible_moves(curr_state)
        if heuristic != 0:
            possible_moves = sort_by_heuristic(possible_moves, goal_state, heuristic)
        for move in possible_moves:
            curr_move = move.reshape(-1).tolist()
            if curr_move not in frontier.tolist():
                if curr_move not in visited.tolist():
                    frontier = np.vstack((frontier, move.reshape(-1)))
        if (frontier == np.array([])):
            print("STRUCK!!!")
            return
        if (visited == np.array([])).all():
            visited = np.array(curr_state.reshape(-1,1))
        else:
            visited = np.vstack((visited, curr_state.reshape(-1)))
        frontier = np.delete(frontier, 0, 0)
        curr_state = frontier[0].reshape(3,3)
    print("GOAL REACHED!!!")
    print(curr_state)

CURR_STATE = generate_instance(GOAL_STATE, 8)
print("CURRENT STATE")
print(CURR_STATE)

solve2(CURR_STATE, GOAL_STATE, 1)